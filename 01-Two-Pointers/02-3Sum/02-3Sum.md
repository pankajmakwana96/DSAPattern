# 3Sum

**LeetCode Link:** https://leetcode.com/problems/3sum/

**Difficulty:** Medium

**Pattern:** Two Pointers

## Problem Description

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
```

**Example 2:**
```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**
```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

## Approaches

### Approach 1: Sort + Two Pointers (Optimal)

**Intuition:**
- Sort the array first
- Fix one element and use two pointers to find the other two elements
- Skip duplicates to avoid duplicate triplets
- For each fixed element, use two pointers (left and right) to find pairs that sum to the target

**Algorithm:**
1. Sort the array
2. Iterate through the array (i from 0 to n-3):
   - Skip duplicates for the first element
   - Set target = -nums[i]
   - Use two pointers: left = i+1, right = n-1
   - While left < right:
     - If sum == target: add to result, skip duplicates, move both pointers
     - If sum < target: move left pointer right
     - If sum > target: move right pointer left
3. Return result

**Time Complexity:** O(n²) - O(n log n) for sorting + O(n²) for two pointers iteration
**Space Complexity:** O(1) or O(n) depending on sorting algorithm (excluding output space)

### Approach 2: Brute Force (Not Recommended)

**Intuition:**
- Check all possible triplets using three nested loops
- Use a set to avoid duplicates

**Time Complexity:** O(n³)
**Space Complexity:** O(n) for the set

**Note:** This approach is too slow for large inputs.

## Code Implementation

### Java Solution
See: `ThreeSum.java`

### C++ Solution
See: `ThreeSum.cpp`

## Key Takeaways

1. Sorting helps in using two pointers technique effectively
2. Skip duplicates to avoid duplicate triplets in the result
3. Fix one element and convert 3Sum to 2Sum problem
4. Two pointers approach significantly reduces time complexity from O(n³) to O(n²)
5. Be careful with edge cases: array size < 3, all zeros, etc.

## Common Pitfalls

1. Forgetting to skip duplicates
2. Not handling edge cases (array size < 3)
3. Off-by-one errors in pointer movements
4. Not sorting the array before applying two pointers
